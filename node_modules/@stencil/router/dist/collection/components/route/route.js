var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { matchPath } from '../../utils/match-path';
import ActiveRouter from '../../global/active-router';
/**
  * @name Route
  * @module ionic
  * @description
 */
export class Route {
    constructor() {
        this.group = null;
        this.groupMatch = null;
        this.componentUpdated = null;
        this.match = null;
        this.unsubscribe = () => { return; };
        this.componentProps = {};
        this.exact = false;
        this.routeRender = null;
        this.scrollTopOffset = null;
        this.scrollOnNextRender = false;
    }
    componentWillLoad() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.groupMatch) {
                this.groupMatchChanged(this.groupMatch);
            }
        });
    }
    groupMatchChanged(groupMatchValue) {
        this.match = groupMatchValue;
    }
    // Identify if the current route is a match.
    computeMatch() {
        // If you are in a group then your switch handles this.
        if (this.group) {
            return;
        }
        this.match = matchPath(this.location.pathname, {
            path: this.url,
            exact: this.exact,
            strict: true
        });
    }
    componentDidUpdate() {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.componentUpdated === 'function') {
                // Wait for all children to complete rendering before calling componentUpdated
                yield Promise.all(Array.from(this.el.children).map((element) => {
                    if (element.componentOnReady) {
                        return element.componentOnReady();
                    }
                    return Promise.resolve(element);
                }));
                // After all children have completed then tell switch
                // the provided callback will get executed after this route is in view
                if (typeof this.componentUpdated === 'function') {
                    this.componentUpdated(this.scrollTo.bind(this));
                }
            }
        });
    }
    scrollTo() {
        if (this.scrollTopOffset == null || !this.history || this.isServer) {
            return;
        }
        if (this.history.action === 'POP' && this.history.location.scrollPosition != null) {
            return this.queue.write(() => {
                window.scrollTo(this.history.location.scrollPosition[0], this.history.location.scrollPosition[1]);
            });
        }
        // okay, the frame has passed. Go ahead and render now
        return this.queue.write(() => {
            window.scrollTo(0, this.scrollTopOffset);
        });
    }
    render() {
        // If there is no activeRouter then do not render
        // Check if this route is in the matching URL (for example, a parent route)
        if (!this.match) {
            return null;
        }
        // component props defined in route
        // the history api
        // current match data including params
        const childProps = Object.assign({}, this.componentProps, { history: this.history, match: this.match });
        // If there is a routerRender defined then use
        // that and pass the component and component props with it.
        if (this.routeRender) {
            return this.routeRender(Object.assign({}, childProps, { component: this.component }));
        }
        if (this.component) {
            const ChildComponent = this.component;
            return (h(ChildComponent, Object.assign({}, childProps)));
        }
    }
    static get is() { return "stencil-route"; }
    static get properties() { return {
        "component": {
            "type": String,
            "attr": "component"
        },
        "componentProps": {
            "type": "Any",
            "attr": "component-props"
        },
        "componentUpdated": {
            "type": "Any",
            "attr": "component-updated"
        },
        "el": {
            "elementRef": true
        },
        "exact": {
            "type": Boolean,
            "attr": "exact"
        },
        "group": {
            "type": String,
            "attr": "group"
        },
        "groupMatch": {
            "type": "Any",
            "attr": "group-match",
            "watchCallbacks": ["groupMatchChanged"]
        },
        "history": {
            "type": "Any",
            "attr": "history"
        },
        "isServer": {
            "context": "isServer"
        },
        "location": {
            "type": "Any",
            "attr": "location",
            "watchCallbacks": ["computeMatch"]
        },
        "match": {
            "state": true
        },
        "queue": {
            "context": "queue"
        },
        "routeRender": {
            "type": "Any",
            "attr": "route-render"
        },
        "scrollTopOffset": {
            "type": Number,
            "attr": "scroll-top-offset"
        },
        "url": {
            "type": String,
            "attr": "url"
        }
    }; }
    static get style() { return "/**style-placeholder:stencil-route:**/"; }
}
ActiveRouter.injectProps(Route, [
    'location',
    'history'
]);
