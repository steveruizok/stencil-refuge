var DEFAULT_DELIMITER = "/", DEFAULT_DELIMITERS = "./", PATH_REGEXP = new RegExp(["(\\\\.)", "(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?"].join("|"), "g");
function parse(e, t) { for (var n, r = [], a = 0, i = 0, o = "", s = t && t.delimiter || DEFAULT_DELIMITER, p = t && t.delimiters || DEFAULT_DELIMITERS, c = !1; null !== (n = PATH_REGEXP.exec(e));) {
    var u = n[0], d = n[1], g = n.index;
    if (o += e.slice(i, g), i = g + u.length, d)
        o += d[1], c = !0;
    else {
        var l = "", h = e[i], f = n[2], E = n[3], v = n[4], x = n[5];
        if (!c && o.length) {
            var m = o.length - 1;
            p.indexOf(o[m]) > -1 && (l = o[m], o = o.slice(0, m));
        }
        o && (r.push(o), o = "", c = !1);
        var R = "" !== l && void 0 !== h && h !== l, T = "+" === x || "*" === x, w = "?" === x || "*" === x, L = l || s, A = E || v;
        r.push({ name: f || a++, prefix: l, delimiter: L, optional: w, repeat: T, partial: R, pattern: A ? escapeGroup(A) : "[^" + escapeString(L) + "]+?" });
    }
} return (o || i < e.length) && r.push(o + e.substr(i)), r; }
function escapeString(e) { return e.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1"); }
function escapeGroup(e) { return e.replace(/([=!:$/()])/g, "\\$1"); }
function flags(e) { return e && e.sensitive ? "" : "i"; }
function regexpToRegexp(e, t) { if (!t)
    return e; var n = e.source.match(/\((?!\?)/g); if (n)
    for (var r = 0; r < n.length; r++)
        t.push({ name: r, prefix: null, delimiter: null, optional: !1, repeat: !1, partial: !1, pattern: null }); return e; }
function arrayToRegexp(e, t, n) { for (var r = [], a = 0; a < e.length; a++)
    r.push(pathToRegexp(e[a], t, n).source); return new RegExp("(?:" + r.join("|") + ")", flags(n)); }
function stringToRegexp(e, t, n) { return tokensToRegExp(parse(e, n), t, n); }
function tokensToRegExp(e, t, n) { for (var r = (n = n || {}).strict, a = !1 !== n.end, i = escapeString(n.delimiter || DEFAULT_DELIMITER), o = n.delimiters || DEFAULT_DELIMITERS, s = [].concat(n.endsWith || []).map(escapeString).concat("$").join("|"), p = "", c = !1, u = 0; u < e.length; u++) {
    var d = e[u];
    if ("string" == typeof d)
        p += escapeString(d), c = u === e.length - 1 && o.indexOf(d[d.length - 1]) > -1;
    else {
        var g = escapeString(d.prefix), l = d.repeat ? "(?:" + d.pattern + ")(?:" + g + "(?:" + d.pattern + "))*" : d.pattern;
        t && t.push(d), d.optional ? d.partial ? p += g + "(" + l + ")?" : p += "(?:" + g + "(" + l + "))?" : p += g + "(" + l + ")";
    }
} return a ? (r || (p += "(?:" + i + ")?"), p += "$" === s ? "$" : "(?=" + s + ")") : (r || (p += "(?:" + i + "(?=" + s + "))?"), c || (p += "(?=" + i + "|" + s + ")")), new RegExp("^" + p, flags(n)); }
function pathToRegexp(e, t, n) { return e instanceof RegExp ? regexpToRegexp(e, t) : Array.isArray(e) ? arrayToRegexp(e, t, n) : stringToRegexp(e, t, n); }
var patternCache = {}, cacheLimit = 1e4;
var cacheCount = 0;
function compilePath(e, t) { var n = "" + t.end + t.strict, r = patternCache[n] || (patternCache[n] = {}), a = JSON.stringify(e); if (r[a])
    return r[a]; var i = [], o = { re: pathToRegexp(e, i, t), keys: i }; return cacheCount < cacheLimit && (r[a] = o, cacheCount += 1), o; }
function matchPath(e, t) {
    if (t === void 0) { t = {}; }
    "string" == typeof t && (t = { path: t });
    var _a = t.path, n = _a === void 0 ? "/" : _a, _b = t.exact, r = _b === void 0 ? !1 : _b, _c = t.strict, a = _c === void 0 ? !1 : _c, _d = compilePath(n, { end: r, strict: a }), i = _d.re, o = _d.keys, s = i.exec(e);
    if (!s)
        return null;
    var p = s[0], c = s.slice(1), u = e === p;
    return r && !u ? null : { path: n, url: "/" === n && "" === p ? "/" : p, isExact: u, params: o.reduce(function (e, t, n) { return e[t.name] = c[n], e; }, {}) };
}
var canUseDOM = !("undefined" == typeof window || !window.document || !window.document.createElement), addEventListener = function (e, t, n) { return e.addEventListener ? e.addEventListener(t, n, !1) : e.attachEvent("on" + t, n); }, removeEventListener = function (e, t, n) { return e.removeEventListener ? e.removeEventListener(t, n, !1) : e.detachEvent("on" + t, n); }, getConfirmation = function (e, t) { return t(window.confirm(e)); }, isModifiedEvent = function (e) { return e.metaKey || e.altKey || e.ctrlKey || e.shiftKey; }, supportsHistory = function () { var e = window.navigator.userAgent; return (-1 === e.indexOf("Android 2.") && -1 === e.indexOf("Android 4.0") || -1 === e.indexOf("Mobile Safari") || -1 !== e.indexOf("Chrome") || -1 !== e.indexOf("Windows Phone")) && window.history && "pushState" in window.history; }, supportsPopStateOnHashChange = function () { return -1 === window.navigator.userAgent.indexOf("Trident"); }, supportsGoWithoutReloadUsingHash = function () { return -1 === window.navigator.userAgent.indexOf("Firefox"); }, isExtraneousPopstateEvent = function (e) { return void 0 === e.state && -1 === navigator.userAgent.indexOf("CriOS"); }, storageAvailable = function (e) { try {
    var t = window[e], n = "__storage_test__";
    return t.setItem(n, n), t.removeItem(n), !0;
}
catch (e) {
    return e instanceof DOMException && (22 === e.code || 1014 === e.code || "QuotaExceededError" === e.name || "NS_ERROR_DOM_QUOTA_REACHED" === e.name) && 0 !== t.length;
} };
export { matchPath as a, isModifiedEvent as b, storageAvailable as c, canUseDOM as d, addEventListener as e, removeEventListener as f, getConfirmation as g, supportsHistory as h, supportsPopStateOnHashChange as i, isExtraneousPopstateEvent as j, supportsGoWithoutReloadUsingHash as k };
